# 复习内容

### 选择排序

#### 选择排序的C实现

```c
#include<stdio.h>
int main()
{
    void sort(int a[],int n);
    int i,a[10];
    for(i=0;i<10;i++)
        scanf("%d",&a[i]);
    sort(a,10);
    for(i=0;i<10;i++)
        printf("%5d",a[i]);
    printf("\n");
    return 0;
}
void sort(int a[],int n)
{
    int min,t;
    for(int i=0;i<n;i++)
    {
        min = i;
        for(int j=i+1;j<n;j++)
        {
            if(a[min]>a[j]) min = j;
        }
        t = a[i];
        a[i] = a[min];
        a[min] = t;
    }
}
```

#### 选择排序C++实现

```c++
#include<iostream>
using namespace std;
int main()
{
    int a[10];
    int i,j,min;
    for(i=0;i<10;i++)
        cin>>a[i];
    for(i=0;i<10;i++)
    {
        min = i;
        for(j = i+1;j<10;j++)
        {
            if(a[min]>a[j]) min = j;
        }
        int t;
        t = a[i];
        a[i] = a[min];
        a[min] = t;
    }
    for(i=0;i<10;i++)
        cout<<a[i]<<" ";
    cout<<endl;
    return 0;
}
```

#### 冒泡排序

```c++
#include<iostream>
using namespace std;
int main()
{
    int n;
    int t;
    int *a = new int[n];
    for(int i=0;i<n;i++)
        cin>>a[i];
    for(int i=0;i<n-1;i++)
        for(int j=0;j<n-1-i;j++)
        {
            if(a[j]>a[j+1])
            {
                t = a[j];
                a[j] = a[j+1];
                a[j+1] = t;
            }
        }
    for(int i=0;i<n;i++)
        cout<<a[i]<<" ";
    cout<<endl;
    return 0;
}
```



#### 链表

```c++
#include<iostream>
using namespace std;

struct Snode
{
    int data;
    struct *next;
};
class List
{
    Snode *head,*tail;
public:
    List()
    {
        head = new Snode;
        head->next = NULL;
        tail = head;
    }
    Snode createList(int *value,int n)
    {
        Snode *p;
        for(int i=0;i<n;i++)
        {
            p = new Snode;
            p->data = value[i];
            p->next = NULL;
            tail->next = p;
            tail = p;
            //tail = tail->next;
        }
    }
    void printList()
    {
        Snode *p;
        for(p = head->next;p->next!=NULL;p = p->next)
        {
            cout<<p->data<<" ";
        }
        cout<<p->data<<endl;
    }
    int insertNode(int position,int value)
    {
        Snode *p,*q;
        p = head;
        q = new Snode;
        q->data = value;
        for(int i=0;p!=NULL&&i<position;i++)
        {
            p = p->next;
        }
        if(p==NULL)
        {
            cout<<"error"<<endl;
            return 0;
        }
        q->next = p->next;
        p->next = q;
        return 1;
    }
    int removeList(int position)
    {
        Snode *p,*q;
        if(position <= 0)
        {
            cout<<"error"<<endl;
            return 0;
        }
        p = head;
        for(int i=1;p->next!=NULL&&i<position;i++)
        {
            p = p->next;
        }
        if(p->next == NULL)
        {
            cout<<"error"<<endl;
            return 0;
        }
        q = p->next;
        p->next = q->next;
        return 1;
    }
    ~List()
    {
        Snode *p,*q;
        p = head;
        while(p->next!=NULL)
        {
            q = p->next;
            p->next = q->next;
            delete []q;
        }
        delete []head;
    }
};

int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        class List L;
        int n,*value;
        cin>>n;
        value = new int [n];
        for(int i=0;i<n;i++)
        {
            cin>>value[i];
        }
        L.createList(value,n);
        L.printList();
        int m;
        cin>>m;
        while(m--)
        {
            int index1,num1;
            cin>>index1>>num1;
            if(L.insertNode(index1,num1))
                L.printList();
        }
        int k;
        cin>>k;
        while(k--)
        {
            int index2;
            cin>>index2;
            if(L.removeNode(index2))
                L.printList();
		}
    }
}
```

### string

#### string类型变量的操作

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string a;
    cin>>a;
    string a1(a);//利用构造函数，创建一个a1是a的复制
    cout<<a1<<endl;
    string a2(a,2);//表示从a字符串的第二个位置开始复制
    cout<<a2<<endl;
    string a3(a,2,2);//表示从a字符串的第二个位置开始复制2个字符
    cout<<a3<<endl;
    char b[] = "hello";
    string b1(b);//表示b1是b的复制
    cout<<b1<<endl;
    string b2(b,2);//表示复制b的前两个字符作为b2字符串的内容
    cout<<b2<<endl;
    string str(3,'a');//表示str字符串由3个a组成
    cout<<str<<endl;
    string ab(a.begin(),a.begin()+2);//表示复制a字符串从[开始]到[开始+2]的内容
    cout<<ab<<endl;
    return 0;
}
```

#### string的查找操作

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string a = "hello";
    int b;
    b = a.find("o");//查找o在a字符串中第一次出现位置的下标
    cout<<b<<endl;
    b = a.find("ell");//查找字符串“ell”在a中开始出现的位置的下标
    cout<<b<<endl;
    b = a.find("elu",0,2);//从下标0开始查找elu字符串的前2个字符在a中开始出现的位置
    cout<<b<<endl;
    b = a.find("d");//在helllo中没有d，查找不到返回-1
    cout<<b<<endl;
    b = a.find("o",5);//从下标为5的位置开始查找
    cout<<b<<endl;
    b = a.rfind("l");//从后往前开始查找l第一次出现位置的下标
    cout<<b<<endl;
    b = a.rfind("ell");//从后往前查找ell开始出现的位置的下标
    cout<<b<<endl;
    b = a.rfind("l",2);//从下标为2的字符开始从后往前找l的位置下标
    cout<<b<<endl;
    
    char flag[] = "l";
    int position = 0;
    int i=1;
    while((position = a.find(flag,position))!=-1)
    {
        cout<<"position"<<i<<":"<<position<<endl;
        position++;
        i++;
    }//查找a中flag出现的所有位置
    return 0;
}
```

#### string字符串和数值的转换

##### 字符串转换为数值

```c++
to_string(val);//把val转换成string
stoi(s,p,b);//把字符串s从p开始由b进制转化为十进制的int型
stol(s,p,b);//把字符串s从p开始由b进制转化为十进制的long型
stoul(s,p,b);//把字符串s从p开始由b进制转化为十进制的unsigned long型
stoll(s,p,b);//把字符串s从p开始由b进制转化为十进制的long long型
stoull(s,p,b);//把字符串s从p开始由b进制转化为十进制的unsigned long long型
stof(s,p);//把字符串s从p开始转化成float型
stod(s,p);//把字符串s从p开始转化成double型
stold(s,p);//把字符串s从p开始转化成long double型
```

```c++
#include<bits/stdc++.h>
#include<map>
using namespace std;
int main()
{
    string s = "222.22";
    cout<<"s="<<s<<endl;
    int a = 222;
    int ot = stoi(s,0,10);
    int ol = stol(s,0,10);
    float of = stof(s,0);
    double od = stod(s,0);
    cout<<"ot="<<ot<<endl;
    cout<<"ol="<<ol<<endl;
    cout<<"of="<<of<<endl;
    cout<<"od="<<od<<endl;
    return 0;
}
```

##### 数值转换为字符串

```c++
#include<string>
#include<sstream>
#include<iostream>
using namespace std;
int main()
{
    double a = 123.32;
    string res;
    stringstream ss;
    ss<<a;
    ss>>res;//或者res = ss.str()
    cout<<res;
    return 0;
}
```

#### string常用成员函数

```c++
//assign函数(清空)
str.assign("ABC");//清空字符串，并设置为ABC
str.assign("ABC",2);//清空字符串，并设置为AB，保留两个字符
sre.assign("ABC",1,1);//清空字符串，设置为从ABC的位置1开始保留1个字符
str.assign(5,'A');//清空字符串，设置为5个A

str.length();//求字符串的长度
str.size();//同上
str.capacity();//获取容量，包含了不用增加内存就能使用的字符数
str.reasize(10);//设置当前str的大小为10，若大小大于当前串的长度，\0来填充
str.reasize(10,char c);//设置当前str的大小为10，若大小大于当前串的长度，字符c填充
str.reserve(10);//设置str的容量为10，不会填充数据
str.swap(str1);//交换str和str1
str.push_back('A');//在str结尾添加一个字符'A'，参数必须是字符形式
str.append("ABC");//在str末尾添加一个字符串“ABC”，参数必须是字符串形式

//insert函数
str.insert(2,3,'A');//在下标为2的位置添加3个字符'A'
str.insert(2,"ABC");//在str下标为2的位置添加"ABC"
str.insert(2,"ABC",1);//在str下标为2的位置添加"ABC"中一个字符
str.insert(2,"ABC",1,1);//在str下标为2的位置添加"ABC"从位置1开始的1个字符
str.insert(iterator pos,size_type count,CharT ch);//在str中，迭代器指向pos位置插入count个ch
str.insert(++str1.begin(),2,'a');//结果：ABCD->AaaBCD
str.insert(iterator pos,Inputlt first,Inputlt last);//在str中，pos位置插入str1的开始位置到结束为止
str.insert(s4.begin(),str1.begin(),str1.end());//结果:s4:ABCD str1:abc->abcABCD

str.erase(2);//删除下标2开始之后的全部
str.erase(2,1);//删除下标2开始之后的1个
str.clear();//删除所有
str.replace(2,4,"abcd");//从下标2的位置，替换4个字节为abcd
str.empty();
```



# 数据结构

### 线性表(顺序表)

#### 顺序表（一维数组）

```c++
//顺序表的定义
class SeqList
{
    const int MaxListLen = 100; //MaxListLen表示最大表长
    int data[MaxListLen+1]; //顺序表
    int ListLen; //表的有效长度
public:
    SeqList();//无参构造方法
    SeqList(int a[],int n);//有参构造方法
    int ListLength();//求线性表的长度
    int Get(int i);//取顺序表的第i个元素
    int Locate(int item);//求顺序表值为item的元素符号
    void Print();//按序号依次输出各元素
    void Insert(int i,int item);//在第i个位置插入item
    void Delete(int i);//删除顺序表的第i个元素
};
//顺序表的创建
SeqList(){
    cin>>ListLen;//输入表长
    if(ListLen>MaxListLen) return(1);//出错返回
    for(i=1;i<ListLen;i++)
        cin>>data[i];
}
//顺序表的查找
int Get(int i)
{
    if((i>ListLen)||(i<1)||(ListLen==0)) return 1;
    return data[i];
}
//顺序表的插入
void Insert(int i,int NewItem)
{
    int j;
    if((i>ListLen+1)||(i<1)||(ListLen == MaxListLen)) return 1;
    for(j=ListLen;j>=i;j--)
    {
        data[j+1] = data[j];//后移
    }
    data[i] = NewItem;
    ListLen++;//表长+1
}
//顺序表的删除
void Delete(int i)
{
    if((i>ListLen)||(i<1)||(ListLen == 0)) return 1;
    for(int j = i+1;j<ListLen+1;j++)
        data[j-1] = data[j];//前移
    ListLen--;//表长-1
}
```

#### 顺序表的功能实现

```c++
#include<iostream>
using namespace std;
#define ok 0;
#define error -1;

class SeqList
{
private:
    int maxsize;
    int size;
    int *list;
public:
    SeqList();
    ~SeqList();
    int List_size(int i);
    int insert(int i,int item);
    int del(int i);
    int get(int i);
    void list_display();
};
SeqList::SeqList()
{
    maxsize = 1000;
    size = 0;
    list = new int [maxsize];
}
SeqList::~SeqList(){
    delete []list;
}
int SeqList::List_size(int i)
{
    list[size] = i;
    size++;
}
int SeqList::insert(int i,int item)
{
    if((i<1)||(i>size+1))
    {
        cout<<"error"<<endl;
        return 1;
    }
    for(int j=size;j>=i;j--)
    {
        list[j] = list[j-1];
    }
    list[i] = item;
    size++;
    list_display();
}
int SeqList::del(int i)
{
    if((i<1)||(i>size))
    {
        cout<<"error"<<endl;
        return 1;
    }
    for(int j=i;j<=size;j++)
    {
        list[j-1] = list[j];
    }
    size--;
    list_display();
}
int SeqList::get(int i)
{
    if((i<1)||(i>=size))
    {
        cout<<"error"<<endl;
    }
    else
    {
        cout<<list[i-1]<<endl;
    }
}
void SeqList::list_display()
{
    cout<<size<<" ";
    for(int i=0;i<size;i++)
    {
        cout<<list[i]<<" ";
    }
    cout<<endl;
}
int main()
{
    int a,n;
    cin>>n;
    SeqList L;
    for(int i=0;i<n;i++)
    {
        cin>>a;
        L.List_size(a);
    }
    L.list_display();
    int p,item;
    cin>>p>>item;
    L.insert(p,item);
    cin>>p;
    L.del(p);
    cin>>p;
    L.get(p);
    return 0;
}
```

#### 利用结构体解决实际问题（股票）

```c++
#include<iostream>
using namespace std;

struct fee
{
    string date;
    string type;
    int s1;
    int s2;
};

int main()
{
    int n,m;
    cin>>n>>m;
    struct fee *f;
    f = new fee [n];
    struct fee temp1[10];
    struct fee temp2[10];
    int num1,num2=0;
    for(int i=0;i<n;i++)
    {
        cin>>f[i].date>>f[i].type>>f[i].s1>>f[i].s2;
        if(f[i].type == "close")
        {
            temp1[num1].date = f[i].date;
            temp1[num1].s1 = f[i].s1;
            temp1[num1].s2 = f[i].s2;
            num1++;
        }
        else if(f[i].type == "open")
        {
            temp2[num2].date = f[i].date;
            temp2[num2].s1 = f[i].s1;
            temp2[num2].s2 = f[i].s2;
            num2++;
        }
    }
    for(int i=0;i<num2;i++)
    {
        int min;
        min = i;
        for(int j=i+1;j<num2;j++)
        {
            if(temp2[min].date>temp2[j].date) min = j;
        }
        struct fee t;
        t = temp2[i];
        temp2[i] = temp2[min];
        temp2[min] = t;
    }
    for(int j=m-1;j<num2;j++)
    {
        int s1,s2 = 0;
        for(int i=1;i<m;i++)
        {
            s1=temp2[j].s1+temp2[j-i].s1;
            s2=temp2[j].s2+temp2[j-i].s2;
        }
        s1 /= m;
        s2 /= m;
        cout<<temp2[j].date<<" open "<<s1<<" "<<s2<<endl;
    }
    for(int i=0;i<num1;i++)
    {
        int min;
        min = i;
        for(int j=i+1;j<num1;j++)
        {
            if(temp1[min].date>temp1[j].date) min = j;
        }
        struct fee t;
        t = temp1[i];
        temp1[i] = temp1[min];
        temp1[min] = t;
    }
    for(int j=m-1;j<num1;j++)
    {
        int s1,s2 = 0;
        for(int i=1;i<m;i++)
        {
            s1=temp1[j].s1+temp1[j-i].s1;
            s2=temp1[j].s2+temp1[j-i].s2;
        }
        s1 /= m;
        s2 /= m;
        cout<<temp1[j].date<<" close "<<s1<<" "<<s2<<endl;
    }
    return 0;
}
```

### 链式存储实现

```c++
typedef struct LNode *List
struct LNode
{
    Elementype data;
    List Next;
};
struct LNode L;
List PtrL;

//求表长(遍历链表的方法)
int length(List PtrL)
{
    List p = PtrL; //p指向表的第一个结点
    int j = 0;
    while(p)
    {
        p = p->Next;
        j++;  //当前p指向的是第j个结点
    }
    return j;
}
//查找
List findKth(int K,List PtrL)//按序号查找
{
    List p = PtrL;
    int i = 1;
    while(p!=NULL && i<K)
    {
        p = p->next;
        i++;
    }//退出循环有两种可能:p == NULL || i == K
    if(i==K)
    {
        return p;
    }
    else return NULL;
}

List Find(Elementype X,List PtrL)//按值查找
{
    List p = PtrL;
    while(p!=NULL && p->data!=X)
    {
        p = p->next;
    }
    return p; //结果return X或return NULL
}

//插入
List Insert(Elementype X,int i,List PtrL)
{
    List p,s;
    if(i==1)//新结点插入在表头
    {
        s = (List)malloc(sizeof(struct LNode));
        s->data = X;
        s->next = PtrL;
        return s;
    }
    p = findKth(i-1,PtrL);//查找第i-1个结点
    if(p == NULL)//第i-1个结点不存在
    {
        printf("error");
        return NULL;
    }
    else
    {
        s = (List)malloc(sizeof(struct LNode));
        s->data = X;
        s->next = p->next;
        p->next = s;
        return PtrL;
    }
}

//删除
List Delete(int i.List PtrL)
{
    List p,s;
    if(i==1)//删除第一个结点
    {
        s = PtrL;
        if(PtrL!=NULL) PtrL = PtrL->next;
        else return NULL;
        free(s);
        return PtrL;
    }
    p = findKth(i-1,PtrL)
    if(p==NULL)
    {
        printf("不存在");
        return NULL;
    }
    else if(p->next == NULL)
    {
        printf("不存在");
        return NULL;
    }
    else
    {
        s = p->next;
        p->next = s->next;
        free(s);
        return PtrL;
    }
}
```

####  线性链表的实现

```c++
#include<iostream>
using namespace std;
#define ok 0
#define error -1
//线性链表的定义
class LNode//定义一个结点
{
public:
    int data;
    LNode *next;
    LNode()
    {
        next = NULL;
    }
};//也可以定义为结构体
class LinkList//定义链表类
{
    int len;
    LNode *head;
public:
    LinkList()
    {
        head = new LNode;
        len = 0;
    }
    ~LinkList();
    LNode *searchLinkList(int i);
    void create();
    void printList();
    int insert(int i,int item);
    int Delete(int i);
    int ListLength();
};
LNode * LinkList::searchLinkList(int i) {
    //head为单链表的头结点，i为待查找的第i个元素
    LNode *p;
    if(len==0||i<1||i>len)
    {
        return (NULL);
    }
    p = head;
    for(int j=0;j<i;j++)
    {
        p = p->next;
    }
    return p;
}
int LinkList::insert(int i, int item) {
    LNode *p,*s;
    if(i==1) p = head;
    else
    {
        p = searchLinkList(i-1);
        if(!p)//如果此时p为空，则不存在
            return error;
    }
    s = new LNode;
    s->data = item;
    len++;
    s->next = p->next;
    p->next = s;
    return ok;
}
void LinkList::create() {
    cin>>len;
    LNode *p = head,*s;
    for(int j=0;j<len;j++)
    {
        s = new LNode;
        cin>>s->data;
        s->next = p->next;
        p->next = s;
        p = s;
    }
}
int LinkList::Delete(int i) {
    LNode *p,*q;
    if(i==1)
    {
        p = head;
    }
    else
    {
        p = searchLinkList(i-1);
        if(!p)
            return error;
    }
    q = p->next;
    p->next = q->next;
    delete q;
    len--;
    return ok;
}
void LinkList::printList() {
    LNode *p;
    p = head->next;
    if(p)
    {
        while(p->next)
        {
            cout<<p->data<<" ";
            p = p->next;
        }
        cout<<p->data<<endl;
    }
}
LinkList::~LinkList() {
    LNode *p;
    while(head)
    {
        p = head->next;
        delete head;
        head = p;
    }
    len = 0;
}
```

完整实现代码：

```c++
#include<iostream>
using namespace std;
#define ok 0
#define error -1

class LNode
{
public:
    int data;
    LNode *next;
    LNode(){
        next = NULL;
    }
};
class LinkList
{
    int len;
    LNode *head;
public:
    LinkList(){
        head = new LNode;
        len = 0;
    }
    ~LinkList(){
        LNode *p;
        while(head)
        {
            p = head->next;
            delete head;
            head = p;
        }
        len = 0;
    }
    LNode *searchLinkList(int i)
    {
        LNode *p;
        if(len==0||i<1||i>len) {
            return NULL;
        }
        p = head;
        for(int j=0;j<i;j++)
        {
            p = p->next;
        }
        return p;
    }
    int insert(int i,int item)
    {
        LNode *p,*s;
        if(i==1) p = head;
        else
        {
            p = searchLinkList(i-1);
            if(!p) return error;
            s = new LNode;
            s->data = item;
            s->next = p->next;
            p->next = s;
            len++;
            return ok;
        }
    }
    void create()
    {
        cin>>len;
        LNode *p = head,*s;
        for(int i=0;i<len;i++)
        {
            s = new LNode;
            cin>>s->data;
            s->next = p->next;
            p->next = s;
            p = s;
        }
    }
    int Delete(int i)
    {
        LNode *p,*s;
        if(len==0||i<1||i>len) return error;
        else if(i==1) p = head;
        else
        {
            p = searchLinkList(i-1);
            if(!p) return error;
        }
        s = new LNode;
        s = p->next;
        p->next = s->next;
        delete s;
        len--;
        return ok;
    }
    void printList()
    {
        LNode *p;
        p = head->next;
        if(p)
        {
            while(p->next)
            {
                cout<<p->data<<" ";
                p = p->next;
            }
            cout<<p->data<<endl;
        }
    }
};

int main()
{
    class LinkList L;
    LNode *s;
    L.create();
    L.printList();
    int p;
    cin>>p;
    s = L.searchLinkList(p);
    cout<<s->data<<endl;
    int i,item;
    cin>>i>>item;
    L.insert(i,item);
    L.printList();
    cin>>p;
    L.Delete(p);
    L.printList();
    return 0;
}
```

#### 循环列表的实现

```c++
#include<iostream>
using namespace std;
#define ok 0
#define error -1
class LNode
{
public:
    int data;
    LNode *next;
    LNode(){
        next = NULL;
    }
};
class LinkList
{
    int len;
    LNode *head;
public:
    LinkList(){
        head = new LNode;
        head->next = head;//与单链表不同
        len = 0;
    }
    void createList()
    {
        cin>>len;
        LNode *p = head,*s;
        for(int i=0;i<len;i++)
        {
            s = new LNode;
            cin>>s->data;
            s->next = head;
            p->next = s;
            p = s;
        }
    }
    ~LinkList(){
        LNode *p;
        while(head->next!=head){
            p = head->next;
            head->next = p->next;
            delete p;
        }
        delete head;
        head = NULL;
        len = 0;
    }
    LNode *searchLinkList(int i)
    {
        LNode *p;
        if(len==0||i<1||i>len) return (NULL);
        p = head;
        for(int j=0;j<i;j++)
        {
            p = p->next;
        }
        return p;
    }
    void printList()
    {
        LNode *p;
        p = head->next;
        if (p!=head)
        {
            while(p->next!=head)
            {
                cout<<p->data<<" ";
                p = p->next;
            }
            cout<<p->data<<endl;
        }
    }
    int insert(int i,int item)
    {
        LNode *p,*s;
        if(i==1) p = head;
        else
        {
            p = searchLinkList(i-1);
            if(!p) return error;
        }
        s = new LNode;
        s->data = item;
        s->next = p->next;
        p->next = s;
        len++;
        return ok;
    }
    int Delete(int i)
    {
        LNode *p,*q;
        if(i==1) p = head;
        else
        {
            p = searchLinkList(i-1);
            if(!p) return error;
        }
        q = p->next;
        p->next = q->next;
        delete q;
        len--;
        return ok;
    }
};
int main()
{
    LinkList L;
    L.createList();
    L.printList();
    
    if(!L.insert(1,100)) //插入成功返回0，!0执行
        L.printList();
    else
        cout<<"error"<<endl;
    
    if(!L.Delete(1))
        L.printList();
    else 
        cout<<"error"<<endl;
    
    return 0;
}
```



#### 链表的应用

##### 循环链表（约瑟夫环）

```c++
#include<iostream>
using namespace std;

class LNode
{
public:
    int data;
    LNode *next;
};
class List
{
    LNode *head;
public:
    List(int n)
    {
        head = new LNode;
        head->next = head;
        head->data = 1;

        LNode *p,*s;
        p = head;
        for(int i=2;i<=n;i++){
            s = new LNode;
            s->data = i;
            s->next = p->next;
            p->next = s;
            p = s;
        }
    }
    void print(int k,int s)
    {
        LNode *p = head,*q;
        for(int i=0;i<s;i++)
            p = p->next;    //p指向第s个结点，即从这个位置开始报数
        while(p->next!=p){
            for(int i=0;i<k-2;i++)
                p = p->next;
            q = p->next;    //q指向要删除的元素，输出（报数）并删除
            cout<<q->data<<" ";
            p->next = q->next;
            delete q;
            p = p->next;    //p指向下一个报1的结点
        }
        cout<<p->data<<" "<<endl;
        delete p;
        head = NULL;
    }
};

int main()
{
    int n,k,s;
    while(cin>>n>>k>>s)
    {
        List L(n);
        L.print(k,s);
    }
    return 0;
}
```

### 堆栈

#### 堆栈的抽象数据类型描述

类型名称：堆栈（Stack）

数据对象集：一个有0个或多个元素的有穷线性表

操作集：长度为MaxSize的堆栈S包含于Stack，堆栈元素item属于ElementType

```c++
1.Stack CreateStack(int MaxSize);//生成空堆栈，其最大长度为MaxSize
2.int IsFull(Stack S,int MaxSize);//判断堆栈S是否已满
3.void Push(Stack S,ElementType item);//将元素item压入堆栈
4.int IsEmpty(Stack S);//判断堆栈S是否为空
5.ElementType Pop(Stack S);//删除并返回栈顶元素
```

#### 栈的顺序存储实现

栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成。

```c++
#define MaxSize <储存数据元素的最大个数>
typedef struct SNode *Stack;
struct SNode
{
    ElementType Data[MaxSize];
    int top;
};

//入栈
void Push(Stack PtrS,ElementType item){
    if(PtrS->Top==MaxSize-1){
        printf("堆栈满");
        return;
    }
    else
    {
        PtrS->Data[++(PtrS->Top)] = item;
        return ;
    }
}
//出栈
ElementType Pop(Stack PtrS){
    if(PtrS->Top == -1){
        printf("堆栈空");
        return error;
    }
    else
    {
        return(PtrS->Data[(PtrS->Top)--]);
    }
}
```

例：用一个数组实现两个堆栈，要求最大地利用数组空间，使数组只要 有空间入栈操作就可以成功

正确操作：从两头分别入栈

->[______]<-		当两个指针相遇时，栈满。

```c
#define MaxSize <存储数据元素的最大个数>
struct DStack
{
    ElementType Data[MaxSize];
    int Top1;
    int Top2;
}S;
S.Top1 = -1;
S.Top2 = MaxSize;

vois Push(struct DStack *PtrS,ElementType item,int tag){
    if(PtrS->Top2-PtrS->Top1 == 1)
    {
        printf("堆栈满");
        return ;
    }
    if(tag == 1)//对第一个栈进行操作
    {
        PtrS->Data[++(PtrS->Top1)] = item;
    }
    else
    {
        PtrS->Data[--(PtrS->Top2)] = item;
    }
}
ElementType Pop(struct DStack *PtrS, int tag){
    if(tag == 1){
        if(PtrS->Top1 == -1)
        {
            printf("堆栈满");
            return NULL;
        }
        else
            return PtrS->Data[(PtrS->Top1)--];
    }
    else
    {
        if(PtrS->Top2 == MaxSize)
        {
            printf("堆栈满");
            return NULL;
        }
        else
            return PtrS->Data[(PtrS->Top2)++];
    }
}
```



#### 堆栈的链式存储实现

栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。链栈的栈顶Top应该在链表的**头位置**。

```c
typedef struct SNode *Stack;
struct SNode
{
    ElementType Data;
    struct SNode *Next;
};
Stack createStack()
{
    //构建一个堆栈的头结点，返回指针
    Stack S;
    S = (Stack)malloc(sizeof(struct SNode));
    //S = new SNode;
    S->Next = NULL;
    return S;
}
int IsEmpty(Stack S)
{
    return (S->Next == NULL);
    //如果堆栈S为空，返回1，否则返回0
}
void Push(ElementType item,Stack S)
{
    struct SNode *Temp;
    Temp = (struct SNode *)malloc(sizeof(struct SNode));
    Temp->Element = item;
    Temp->Next = S->Next;
    S->Next = Temp;
}
ElementType Pop(Stack S)
{
    struct SNode *FirstCell;
    ElementType Top;
    if(IsEmpty(S))
    {
        printf("堆栈空");
        return NULL;
    }
    else
    {
        FirstCell = S->Next;
        S->Next = FirstCell->Next;
        Top = FirstCell->Element;
        free(FirstCell);
        return Top;
    }
}
```

### 队的实现

#### 循环队列

队空：front = = rear； 队满：front == (rear+1)%N;

```c++
//循环列表中插入元素（在队尾插入）
int EnQueue(int item)
{
    if((rear+1)%MaxxSize == front ) return(error);
    else
    {
        base[rear] = item;
        rear = (rear+1)%MaxSize;
        return(correct);
    }
}
//循环列表删除元素（从队首删除）
int DeQueue(int &item)
{
    if(rear == front) return (error);
    item = base[Q.front];
    front = (front+1)%MaxSize;
    return(correct);
}

```

### 串

#### KMP

```c++
#include<iostream>
#include<string>
using namespace std;
class myString
{
private:
    string main_str;
    string str;
    int *next;
    void getNext();
public:
    myString();
    ~myString();
    int KMPFindSubstr();
    void show();
};
myString::myString() {
    cin>>main_str>>str;
    next = new int[str.length()];
}
myString::~myString() {
    delete []next;
}
int myString::KMPFindSubstr() {
    int i=1,j=0;
    int m = main_str.length();
    int n = str.length();
    while(i<m&&j<n)
    {
        if((j==-1)||(main_str[i]==str[j])){
            ++i;
            ++j;
        }
        else j = next[j];
    }
    if(j==n) return(i-j);
    else return -1;
}
void myString::getNext() {
    int j,k;
    j = 0,k = -1;
    int m = str.length();
    next[0] = -1;
    while(j<m-1)
    {
        if((k==-1)||(str[j]==str[k]))
        {
            ++j;
            ++k;
            next[j] = k;
        }
        else
            k = next[k];
    }
}
void myString::show() {
    getNext();
    for(int i=0;i<str.length();i++)
    {
        cout<<next[i]<<" ";
    }
    cout<<endl;
    cout<<KMPFindSubstr()+1<<endl;
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        myString S;
        S.KMPFindSubstr();
        S.show();
    }
    return 0;
}
```

#### 串替换

```c++
#include<iostream>
#include<string>
using namespace std;

class myString
{
private:
    string main_str;
    string str;
    string s;
    int *next;
    void getNext()
    {
        int j,k;
        j = 0,k = -1;
        next[0] = -1;
        while(j<str.length())
        {
            if((k==-1)||(str[j] == str[k]))
            {
                ++j;
                ++k;
                next[j] = k;
            }
            else
                k = next[k];
        }
    }
public:
    myString()
    {
        cin>>main_str>>str>>s;
        next =new int[str.length()];
    }
    ~myString(){
        delete []next;
    }
    int KMP() {
        int i, j;
        i = 1; j = 1;
        int m = main_str.length();
        int n = str.length();
        while (i<m && j<n) 
		{
            if ((j == -1) || (main_str[i] == str[j])) {
                ++i;
                ++j;
            } 
			else
                j = next[j];
        }
        if (j == n)
        {
        	return i-j;
		}
        else
            return -1;
    }
    void show()
    {
        getNext();
        int p = KMP();
        cout<<main_str<<endl;
        if(p == -1)
            cout<<main_str<<endl;
        else
        {
            cout<<main_str.replace(p,str.length(),s)<<endl;
        }
    }
};
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        myString S;
        S.show();
    }
    return 0;
}
```

#### 串的最长真前后缀

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        string s;
        cin>>s;
        int len = s.length();
        int i;
        for(i=len-1;i>0;i--)
        {
            string t1 = s.substr(i,len-i);//后缀
            string t2 = s.substr(0,len-i);//前缀
            if(t1==t2) {
                cout<<t1<<endl;
                break;
            }
        }
        if(i==0) cout<<"empty"<<endl;
    }
    return 0;
}
```

#### 串的最长重复子串

```c++
#include<iostream>
#include<string>
using namespace std;
int Find()
{
    string s;
    cin>>s;
    int len = s.length();
    int i;
    for(i = len/2;i>0;i--)
    {
        for(int j = 0;j<len-i;j++)
        {
            string s1 = s.substr(j,i);
            string s2 = s.substr(i+j);
            if(s2.find(s1)!=string::npos) {
                return i;
            }
        }
    }
    return -1;
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        cout<<Find()<<endl;
    }
    return 0;
}
```

### 树

#### 二叉树

##### 树的遍历

```c++
//定义visit函数
//访问结点，输出结点的层数
void visit(char C)
{
    cout<<"%c is at %d the level of BiTree"<<endl;
}
//先序遍历
void PreOrderTraverse(BiTree T)
{
    if(T)
    {
        visit(T->data);
        PreOrderTraverse(T->lchild);
        PreOrderTraverse(T->rchild);
    }
}
//中序遍历
void InOrderTraverse(BiTree T)
{
    if(T)
    {
        InOderTraverse(T->lchild);
        visit(T->data);
        InOrderTraverse(T->rchild);
    }
}
//后序遍历
void PosOrderTraverse(BiTree T)
{
    if(T)
    {
        PosOrderTraverse(T->lchild);
        PosOrderTraverse(T->rchild);
        visit(T->data);
    }
}
```

##### 创建二叉树

```c++
//先序创建一棵二叉树
void CreateBiTree(BiTree* &T)
{
    char c;
    cin>>c;
    if(c=='0')
        T = NULL;
    else
    {
        T = new BiNode;
        T->data = c;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
}//0是递归结束的标志，当创建到叶子结点时，因为叶子结点的左右子树都为空，因此要输入0表示结束
//在创建二叉树的过程中，程序总是按照：创建根结点-创建左子树-创建右子树顺序进行
```

##### 实例分析（二叉树的创建与遍历）

```c++
//cin:ab##c##
#include<iostream>
using namespace std;
typedef struct BTNode
{
    char data;
    struct BTNode *lchild,*rchild;
}BTNode,*BiTree;
void CreateTree(BiTree&B)
{
    char c;
    cin>>c;
    if(c=='#')
    {
        return;
    }
    if(B == NULL)
    {
        B = new BTNode;
        B->data = c;
        B->lchild = NULL;
        B->rchild = NULL;
    }
    CreateTree(B->lchild);
    CreateTree(B->rchild);
}
void PreTraverseTree(BiTree B)
{
    if(B!=NULL)
    {
        cout<<B->data<<" ";
        PreTraverseTree(B->lchild);
        PreTraverseTree(B->rchild);
    }
    else
    {
        return;
    }
}
void InTraverseTree(BiTree B)
{
    if(B!=NULL)
    {
        InTraverseTree(B->lchild);
        cout<<B->data<<" ";
        InTraverseTree(B->rchild);
    }
    else
    {
        return;
    }
}
void PosTraverseTree(BiTree B)
{
    if(B!=NULL)
    {
        PosTraverseTree(B->lchild);
        PosTraverseTree(B->rchild);
        cout<<B->data<<" ";
    }
    else
    {
        return;
    }
}
int main()
{
    BTNode *pB = NULL;
    CreateTree(pB);
    cout<<"Pre:";
    PreTraverseTree(pB);
    cout<<endl<<"In:";
    InTraverseTree(pB);
    cout<<endl<<"Pos:";
    PosTraverseTree(pB);
    cout<<endl;
    return 0;
}
```

##### 二叉树高度

```c++
#include<iostream>
using namespace std;
class BiNode
{
public:
    char data;
    BiNode *lChild,*rChild;
    BiNode()
    {
        lChild = NULL;
        rChild = NULL;
    }
    BiNode(char ch)
    {
        data = ch;
        lChild = NULL;
        rChild = NULL;
    }
    ~BiNode(){
        if(lChild!=NULL)
            delete lChild;
        if(rChild!=NULL)
            delete rChild;
    }
};
class BiTree
{
public:
    BiNode *root;
    void create(BiNode* &T)
    {
        char c;
        cin>>c;
        if(c=='0')
        {
            T = NULL;
        }
        else
        {
            T = new BiNode(c);
            create(T->lChild);
            create(T->rChild);
        }
    }
    BiTree()
    {
        root = NULL;
    }
    ~BiTree(){
        delete root;
    }
    void create()
    {
        create(root);
    }
};
int height(BiNode *B)
{
    if(!B)
        return 0;
    else
    {
        if(height(B->lChild)>height(B->rChild))
            return height(B->lChild)+1;
        else
            return height(B->rChild)+1;
    }
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        BiTree bt;
        bt.create();
        cout<<height(bt.root)<<endl;
    }
    return 0;
}
```

#### 赫夫曼树

```c++
#include<iostream>
#include<string>
using namespace std;
class HuffNode
{
public:
    int weight;
    int parent;
    int lChild;
    int rChild;
    char c;
    string code;
    HuffNode()
    {
        weight = 0;
        parent = 0;
        lChild = 0;
        rChild = 0;
    }
};
class HuffManTree
{
private:
    void CreateTree()
    {
        for(int i=num+1;i<=len;i++)
        {
            int s1,s2;
            SelectMin(i-1,&s1,&s2);
            HT[s1].parent = HT[s2].parent = i;
            HT[i].lChild = s1;
            HT[i].rChild = s2;
            HT[i].weight = HT[s1].weight+HT[s2].weight;
        }
    }
    void SelectMin(int pos,int *s1,int *s2)
    {
        int Max = 9999;
        int min1 = Max;
        int min2 = Max;
        *s1 = *s2 = 0;
        for(int i=1;i<=pos;i++)
        {
            if(HT[i].parent==0)
            {
                if(min1>HT[i].weight)
                {
                    min2 = min1;
                    *s2 = *s1;
                    min1 = HT[i].weight;
                    *s1 = i;
                }
                else if(min2>HT[i].weight)
                {
                    min2 = HT[i].weight;
                    *s2 = i;
                }
            }
        }
    }
public:
    int num;
    int len;
    HuffNode *HT;
    void CreateTree(int n,int w[],char ch[])
    {
        int i;
        num = n;
        len = 2*n-1;
        HT = new HuffNode[2*n];
        for(i=1;i<=n;i++)
        {
            HT[i].weight = w[i-1];
            HT[i].c = ch[i-1];
        }
        for(i=1;i<=len;i++)
        {
            if(i>n)
                HT[i].weight = 0;
            HT[i].parent = 0;
            HT[i].lChild = 0;;
            HT[i].rChild = 0;
        }
    }
    void coding()
    {
        int i,j,c,f;
        string cd;
        for(i=1;i<=num;i++)
        {
            cd = "";
            for(c=i,f=HT[i].parent;f!=0;c=f,f = HT[f].parent)
            {
                if(HT[f].lChild == c) cd+='0';
                else cd+='1';
            }
            for(j=cd.length()-1;j>=0;j--)
            {
                HT[i].code+=cd[j];
            }
        }
        for(int k=1;k<=num;k++)
        {
            cout<<HT[k].c<<":"<<HT[k].code<<endl;
        }
    }
    void String_coding(string s)
    {
        int l=s.length();
        for(int i=0;i<l;i++)
        {
            for(int j=1;j<=len;j++)
            {
                if(s[i]==HT[j].c)
                    cout<<HT[j].code;
            }
        }
        cout<<endl;
    }
    void Decode(string str)
    {
        int i,f,Root;
        Root = 2*num-1;
        char cha;
        f = Root;
        int l = str.length();
        string result = "";
        for(i=0;i<l;i++)
        {
            cha = str[i];
            if(cha=='0')
                f = HT[f].lChild;
            else if(cha=='1')
                f = HT[f].rChild;
            else
            {
                cout<<"error!"<<endl;
                break;
            }
            if(HT[f].lChild==0&&HT[f].rChild == 1)
            {
                result+=HT[f].c;
                f=Root;
            }
        }
        if(f!=Root)
        {
            cout<<"error!"<<endl;
        }
        else
        {
            cout<<result<<endl;
        }
    }
    void Release()
    {
        num = 0;
        len = 0;
        delete []HT;
    }
};
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        HuffManTree HT;
        int w[800];
        char c[800];
        cin>>n;
        for(int i=0;i<n;i++)
            cin>>c[i];
        for(int i=0;i<n;i++)
            cin>>w[i];
        HT.CreateTree(n,w,c);
        HT.coding();
        string s;
        cin>>s;
        HT.String_coding(s);
        string codestr;
        cin>>codestr;
        HT.Decode(codestr);
        HT.Release();
    }
    return 0;
}
```

### 图

#### 图的存储和遍历

##### 图的邻接矩阵存储及度计算

```c++
#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        char type;
        int n;
        int **graph;
        cin>>type>>n;
        graph = new int*[n];
        for(int i=0;i<n;i++)
            graph[i] = new int[n];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
                graph[i][j] = 0;
        }
        string *str = new string[n];
        for(int i=0;i<n;i++)
            cin>>str[i];
        string node1,node2;
        int flag1,flag2;
        int num;
        cin>>num;
        for(int i=0;i<num;i++)
        {
            cin>>node1>>node2;
            for(int j = 0;j<n;j++)
            {
                if(str[j]==node1)
                    flag1 = j;
                else if(str[j]==node2)
                    flag2 = j;
            }
            if(type == 'D')
                graph[flag1][flag2] = 1;
            else if(type=='U')
            {
                graph[flag1][flag2] = 1;
                graph[flag2][flag1] = 1;
            }
        }
        for(int i=0;i<n;i++) {
            for (int j = 0; j < n; j++)
                cout << graph[i][j] << ' ';
            cout << endl;
        }
        if(type == 'D')
        {
            for(int i=0;i<n;i++) {
                cout << str[i];
                int cnt1 = 0,cnt2 = 0;
                for(int j=0;j<n;j++)
                {
                    if(graph[i][j] == 1)
                        cnt1++;
                    if(graph[j][i]==1)
                        cnt2++;
                }
                if(cnt1||cnt2)
                    cout<<": "<<cnt1<<' '<<cnt2<<' '<<cnt1+cnt2<<endl;
            }
        }
        else if(type=='U')
        {
            for(int i=0;i<n;i++) {
                cout << str[i];
                int cnt = 0;
                for(int j=0;j<n;j++)
                {
                    if(graph[i][j] == 1)
                        cnt++;
                }
                if(cnt)
                    cout<<": "<<cnt<<endl;
            }
        }
    }
    return 0;
}
```

##### 构建邻接表

```c++
#include<iostream>
using namespace std;
class Node
{
public:
    int info;
    Node *next;
    Node()
    {
        info = 0;
        next = NULL;
    }
    Node(int info)
    {
        this->info=info;
        next = NULL;
    }
};
class Graph
{
public:
    int vexnum;
    int arcnum;
    string *vex;
    Node *head;
    Graph(){
        cin>>vexnum>>arcnum;
        vex = new string[vexnum];
        for(int i=0;i<vexnum;i++)
            cin>>vex[i];
        head = new Node[vexnum];
        string node1,node2;
        int flag1,flag2;
        for(int i=0;i<arcnum;i++)
        {
            cin>>node1>>node2;
            flag1 = index(node1);
            flag2 = index(node2);
            Node *p = &head[flag1];
            while(p->next)
                p = p->next;
            Node *s = new Node;
            s->info = flag2;
            p->next = s;
        }
    }
    int index(string s)
    {
        for(int i=0;i<vexnum;i++)
            if(vex[i]==s)
                return i;
    }
    void print()
    {
        for(int i=0;i<vexnum;i++) {
            cout << i << " " << vex[i] << "-";
            Node *p = head[i].next;
            while(p)
            {
                cout<<p->info<<"-";
                p = p->next;
            }
            cout<<"^"<<endl;
        }
    }
};
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        Graph G;
        G.print();
    }
    return 0;
}
```

##### 深度优先遍历(DFS)

```c++
#include<iostream>
using namespace std;
const int MaxLen = 20;
class Map
{
private:
    bool visit[MaxLen];
    int Matrix[MaxLen][MaxLen];
    int Vexnum;
    void DFS(int v)
    {
        int w,i,k;
        visit[v] = true;
        cout<<v<<' ';
        int *AdjVex = new int[Vexnum];
        for(int j=0;j<Vexnum;j++)
            AdjVex[j] = -1;
        k = 0;
        for(int j=0;j<Vexnum;j++) {
            if (Matrix[v][j] == 1) {
                AdjVex[k]=j;
                k++;
            }
        }
        for(int j=0;j<k;j++)
        {
            if(!visit[AdjVex[j]])
                DFS(AdjVex[j]);
        }
    }
public:
    void SetMatrix(int vnum,int mx[MaxLen][MaxLen]){
        int i,j;
        Vexnum = vnum;
        for(i=0;i<MaxLen;i++)
        {
            for(j=0;j<MaxLen;j++)
                Matrix[i][j] = 0;
        }
        for(i=0;i<Vexnum;i++)
            for(j=0;j<Vexnum;j++)
                Matrix[i][j] = mx[i][j];
    }
    void DFSTraverse(){
        for(int i=0;i<Vexnum;i++)
            visit[i] = false;
        for(int i=0;i<Vexnum;i++) {
            if (visit[i] == false)
                DFS(i);
        }
        cout<<endl;
    }
};
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int Matrix[MaxLen][MaxLen];
        int vexnum;
        cin>>vexnum;
        for(int i=0;i<vexnum;i++)
        {
            for(int j=0;j<vexnum;j++)
                cin>>Matrix[i][j];
        }
        Map M;
        M.SetMatrix(vexnum,Matrix);
        M.DFSTraverse();
    }
    return 0;
}
```

#### 最短路径(Dij)

```c++
#include<iostream>
using namespace std;
const int Max = 1000;
class Graph
{
	int vexnum;
	string* Vertex;
	int** Matrix;
	string* path;
	int* Dest;
	string start;
public:
	Graph()
	{
		cin >> vexnum;
		path = new string[vexnum];
		Dest = new int[vexnum];
		Vertex = new string[vexnum];
		for (int i = 0; i < vexnum; i++)
			cin >> Vertex[i];
		Matrix = new int* [vexnum];
		for (int i = 0; i < vexnum; i++)
		{
			Matrix[i] = new int[vexnum];
			for (int j = 0; j < vexnum; j++)
			{
				int e;
				cin >> e;
				if (e == 0)
					Matrix[i][j] = Max;
				else
					Matrix[i][j] = e;
			}
		}
	}
	void Dijkstra(string v)
	{
		start = v;
		int startVex=0;
		bool* final = new bool[vexnum];
		for (int i = 0; i < vexnum; i++)
		{
			if (Vertex[i] == v)
			{
				startVex = i;
				break;
			}
		}
		for (int i = 0; i < vexnum; i++)
		{
			path[i] = v + " ";
			Dest[i] = Max;
			if (Matrix[startVex][i] < Max)
			{
				Dest[i] = Matrix[startVex][i];
				path[i] += Vertex[i] + " ";
			}
			final[i] = false;
		}
		Dest[startVex] = 0;
		final[startVex] = true;
		for (int i = 0; i < vexnum - 1; i++)
		{
			int minDest,currentVex=0;
			minDest = Max;
			for (int j = 0; j < vexnum; j++)
			{
				if (final[j] == false)
				{
					if (Dest[j] < minDest)
					{
						currentVex = j;
						minDest = Dest[j];
					}
				}
			}
			final[currentVex] = true;
			for (int j = 0; j < vexnum; j++)
			{
				if (final[j] == false && (minDest + Matrix[currentVex][j] < Dest[j]))
				{
					Dest[j] = minDest + Matrix[currentVex][j];
					path[j] = path[currentVex];
					path[j] += Vertex[j] + " ";
				}
			}
		}
		for (int i = 1; i < vexnum; i++)
			cout << start<<"-"<<Vertex[i]<<"-" << Dest[i]<<"----["<<path[i] <<"]" << endl;
		cout << endl;
	}
};
int main()
{
	Graph G;
	string v;
	cin >> v;
	G.Dijkstra(v);
	return 0;
}
```

#### 最小生成树（Prim&Kruskal）

```c++
#include<iostream>
using namespace std;
struct Node
{
    int v1;
    int v2;
    int weight;
};
class Map
{
    int n;
    int len;
    int *v;
    int **p;
    string *name;
    Node *node;
public:
    Map()
    {
        cin >> n;
        name = new string[n];
        for (int i = 0; i<n; i++)
            cin >> name[i];
        p = new int *[n];
        for (int i = 0; i<n; i++)
            p[i] = new int[n];
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                p[i][j]=10000;
        v = new int[n];
        cin>>len;
        string str1,str2;
        int *flag1 = new int[len];
        int *flag2 = new int[len];
        int *weight = new int[len];
        for(int i=0;i<len;i++)
        {
            cin>>str1>>str2>>weight[i];
            for(int j=0;j<n;j++)
            {
                if(str1==name[j])
                    flag1[i] = j;
                else if(str2==name[j])
                    flag2[i] = j;
            }
            p[flag1[i]][flag2[i]] = weight[i];
            p[flag2[i]][flag1[i]] = weight[i];
        }
        int t1,t2,t3;
        node = new Node[len];
        for(int i=0;i<len-1;i++)
        {
            for(int j=0;j<len-i-1;j++)
            {
                if(weight[j+1]<weight[j])
                {
                    t1 = flag1[j+1];
                    flag1[j+1] = flag1[j];
                    flag1[j] = t1;
                    t2 = flag2[j+1];
                    flag2[j+1] = flag2[j];
                    flag2[j] = t2;
                    t3 = weight[j+1];
                    weight[j+1] = weight[j];
                    weight[j] = t3;
                }
            }
        }
        for(int i=0;i<len;i++)
        {
            node[i].v1 = flag1[i];
            node[i].v2 = flag2[i];
            node[i].weight = weight[i];
        }
    }
    int findPoint(string str)
    {
        for(int i=0;i<n;i++)
        {
            if(str==name[i])
                return i;
        }
    }
    void Prim()
    {
        string start;
        int p1,p2,min;
        Node *temp = new Node[n];
        for(int i=0;i<n;i++)
           v[i] = 0;
        cin>>start;
        p1 = findPoint(start);
        v[p1] = 1;
        for(int k=0;k<n-1;k++)
        {
            min = 10000;
            for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                {
                    if(v[i]==1&&v[j]==0&&p[i][j]<min)
                    {
                        p1 = i;
                        p2 = j;
                        min = p[i][j];
                    }
                }
            }
            v[p2] = 1;
            temp[k].v1 = p1;
            temp[k].v2 = p2;
            temp[k].weight = min;
        }
        int sum = 0;
        for(int i=0;i<n-1;i++)
            sum += temp[i].weight;
        cout<<sum<<endl;
        cout<<"prim:"<<endl;
        for(int i=0;i<n-1;i++)
        {
            cout<<name[temp[i].v1]<<" "<<name[temp[i].v2]<<" "<<temp[i].weight<<endl;
        }
    }
    void Kruskal()
    {
        cout<<"kruskal:"<<endl;
        int p1,p2,k=0,count=0,q1,q2;
        for(int i=0;i<n;i++)
        {
            v[i]=i;
        }
        while(count<n-1)
        {
            p1 = node[k].v1;
            p2 = node[k].v2;
            if(v[p1]!=v[p2])
            {
                count++;
                q1 = v[p1];
                q2 = v[p2];
                if(node[k].v1<node[k].v2)
                	cout<<name[node[k].v1]<<" "<<name[node[k].v2]<<" "<<node[k].weight<<endl;
            	else
                	cout<<name[node[k].v2]<<" "<<name[node[k].v1]<<" "<<node[k].weight<<endl;
                for(int i=0;i<n;i++)
                {
                    if(v[i]==q1)
                        v[i]=q2;
                }
            }
            k++;
        }
    }
};
int main()
{
    Map M;
    M.Prim();
    M.Kruskal();
    return 0;
}
```



### 查找

#### 查找表

查找表是由同一类型的数据元素（或记录）构成的集合。

对查找表的操作：

```
//1、查询某个“特定的”数据元素是否在查找表中；
//2、检索某个“特定的”数据元素的各种属性
//3、在查找表中插入一个数据元素
//4、从查找表中删去某个数据元素
```

查找表：

```c++
静态查找表：仅作查询和检索操作的查找表
动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素
```

关键字（Key）

```c++
关键字是数据元素（或记录）中某个数据项的值，用以标识（识别）一个数据元素（或记录）
    主关键字：可以识别唯一的一个记录的关键字（如学号）
    此关键字：能识别若干记录的关键字（如性别）
```

平均查找长度ASL

平均查找长度定义为确定记录在表中的位置所进行的和关键字比较的次数的平均值
$$
ASL=PiCi(i从1-n)
$$
n为查找表的长度，即表中所含元素的个数

Pi为查找第i个元素的概率(ΣPi=1)

Ci是查找第i个元素时同给定值K比较的次数

#### 顺序查找

算法：

1、从表中最后一个记录开始

2、逐个进行记录的关键字和给定值的比较

3、若某个记录比较相等，则查找成功

4、若直到第一个记录都比较不等，则查找不成功

查找第i个元素的比较次数（n个元素）：n+1-i

```c++
//定义顺序查找算法所有用到的变量
int ListLen;
int *SeqList;//顺序表
//以下是最终输出结果的变量定义
int SeqSuccess;//成功1，不成功0
int SeqPos;
int SeqCount;
//算法实现
int SeqSearchKey(int Key)
{
    int i;
    SeqList[0] = Key;//哨兵
    i = ListLen;
    while(SeqList[i]!=Key)
        i--;
    SeqSuccess = 1;
    if(i==0) SeqSuccess = 0;//i=0，说明查找到的只是哨兵
    SeqPos = i;
    SeqCount = ListLen+1-i;
    return i;
}
//设置哨兵的目的是省略对下表越界的检查
```

代码实现

```c++
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	int* SeqList;
	SeqList = new int[n+1];
	for (int i = 1; i <= n; i++)
	{
		cin >> SeqList[i];
	}
	int t,key;
	cin >> t;
	while (t--)
	{
		cin >> key;
		int i;
		i = n;
		SeqList[0] = key;
		while (SeqList[i] != key)
			i--;
		if (i == 0)
			cout << "error" << endl;
		else
			cout << i << endl;
	}
	return 0;
}
```

优点：简单；适应面广

缺点：平均查找长度较大；特别是n很大时，查找效率很低

等概率查找下：Pi = 1/n; ASL = (n+1)/2。如果关键字不在表中，ASL = n+1

不等概率查找下：若查找概率无法事先测定，则查找过程采取的改进方法是，在每次查找之后，将刚刚查找到的记录直接移至表尾的位置上。

#### 折半查找

折半查找算法是有序表的查找方法

在折半查找算法中，静态查找表按关键字大小的次序，有序地存放在顺序表中。

原理：

1、先确定待查记录所在的范围（前半部分或后半部分）

2、逐步缩小（一半）范围直到找（不）到该记录为止

算法：

1、n个对象从小到大存放在有序顺序表ST中，k为给定值

2、设low、high指向待查元素所在区间的下界、上界，即low=1，high=n

3、设mid指向待查区间的中点，即mid =(low+high)/2

4、让k与mid指向的记录比较

​	若k=ST[mid].key，查找成功，结束

​	若k<ST[mid].key，则high=mid-1[上半区间]

​	若k>ST[mid].key，则low=mid+1[下半区间]

当下界low大于上界high时，说明有序表中没有关键字等于k的元素，查找不成功

```c++
//定义折半查找算法所有用到的变量
int *BinList;//有序表
int BinListLen;
//以下是最终输出的结果
int BinSuccess;
int BinPos;
int BinCount;
//算法实现
int BinSearchKey(int key)
{
    int Low,Mid,High;
    Low = 1;
    High = BinListLen;
    BinSuccess = 0;BinPos = 0;BinCount = 0;
    while(Low<=High)
    {
        Mid = (Low+High)/2;
        BinCount++;
        if(key == BinList[Mid])
        {
            BinSuccess = 1;
            BinPos = Mid;
            break;
        }
        if(key<BinList[Mid])
            High = Mid-1;
        else 
            Low = Mid+1;
    }
}
//递归实现
int BinSearchKey(int *r,int key,int low,int high)
{
    Low = low;
    High = high;
    BinList = r;
    int mid;
    mid = (low+high)/2;
    BinCount++;
    if(key==BinList[mid])
        return mid;
    if(key<BinList[mid])
        return BinSearchKey(*r,key,low,mid-1);
    else
        return BinSearchKey(*r,key,mid+1,high );
}
```

优点：效率高，特别是n很大的时候

缺点：只适用于有序表，并且以顺序存储结构存储

代码实现

```c
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	int* BinList = new int[n+1];
	for (int i = 0; i < n; i++)
		cin >> BinList[i];
    //for(int i=1;i<=n;i++)
    //cin>>BinList[i];
	int t;
	cin >> t;
	while (t--)
	{
		int low, mid, high;
		low = 0;
		high = n-1;
		int key;
		cin >> key;
        /*
        low = 1;
        high = n;
        int key;
        cin>>key;
        BinList[0] = key;
        */
		while (low<=high)
		{
			mid = (low + high) / 2;
			if (key == BinList[mid]) {
				cout << mid+1 << endl;
                //cout<<mid<<endl;
				break;
			}
			if (key < BinList[mid])
				high = mid - 1;
			else
				low = mid + 1;
		}
		if (low > high)
			cout << "error" << endl;
	}
	return 0;
}
```

#### 分块查找

分块查找是一种索引顺序表（分块有序表）查找方法，是折半查找和顺序查找的简单结合。

索引顺序表（分块有序表）将整个表分成几块，块内无序，块间有序。

所谓块间有序是指后一块表中所有记录的关键字均大于前一块表中的最大关键字。

主表：用数组存放待查记录，每个数据元素至少含有关键字域。

索引表：每个结点含有最大关键字域和指向本快第一个结点的指针。

步骤：

1、采用折半查找方法在索引表（有序）中找到块

2、用顺序查找方法在主表对应块中找到记录

```c++
int Mid,count = 0;
int Low = 0;
int High = n-1;
while(Low<=High)
{
    count++;
    Mid = (Low+High)/2;
    if(Key>index[Mid]&&Mid = n-1)
    {
        BinSuccess = false;
        return;
    }
    if(Key<=index[Mid]&&(Mid==0||Key>index[Mid-1]))
        break;
    if(Key<index[Mid])
        High = Mid-1;
    else
        Low = Mid+1;
}
```

```c++
#include<iostream>
using namespace std;
class SeqIndex
{
public:
	int length;
	int index_length;
	int* item;
	int* index;
	int* indexstart;//存每个最大关键字的起始地址
	SeqIndex(int t)
	{
		length = t;
		item = new int[length];
		for (int i = 0; i < length; i++)
		{
			cin >> item[i];
		}
		cin >> index_length;
		index = new int[index_length];
		for (int i = 0; i < index_length; i++)
		{
			cin >> index[i];
		}
		indexstart = new int[index_length];
		indexstart[0] = 0;
		for (int i = 0; i < index_length; i++)
		{
			for (int j = indexstart[i]; j < length; j++)
			{
				if (item[j] > index[i])
				{
					indexstart[i + 1] = j;
					break;
				}
			}
		}
	}
	void IndexSearch(int key)
	{
		int count = 0;
		for (int i = 0; i < index_length; i++)
		{
			count++;
			if (key <= index[i] || i == index_length - 1)
			{
				int start = indexstart[i];
				int end;
				if (i + 1 >= index_length)
				{
					end = length;
				}
				else
					end = indexstart[i + 1];
				for (int j = start; j < end; j++)
				{
					count++;
					if (item[j] == key)
					{
						cout << j + 1 << "-" << count << endl;
						return;
					}
				}
				cout << "error" << endl;
				return;
			}
		}
	}
};
int main()
{
	int t, p, key;
	while (cin >> t)
	{
		SeqIndex S(t);
		cin >> p;
		while (p--)
		{
			cin >> key;
			S.IndexSearch(key);
		}
	}
}
```



### 动态查找

表结构本身是在查找过程中建成的，查找不到则插入。

#### 二叉排序树

空树或者是具有如下特性的二叉树：

（1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值；

（2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值；

（3）它的左右子树也都分别是二叉排序树。

二叉查找树又称二叉查找树

##### 查找（插入）

查找算法：

```c#
给定值与根结点比较
1.若相等，查找成功
2.若小于，查找左子树
3.若大于，查找右子树
```

```c++
//二叉排序树通常采用二叉链表的形式进行存储
//结点结构定义
class BiNode
{
public:
    int data;
    BiNode *lChild,*rChild;
    BiNode():lChild(NULL),rChild(NUll){}
};
//定义二叉排序树所有用到的变量
BiNode *root;
int BisCount;
int BisSuccess;
//查找函数(递归实现)
void SearchBST(int k)
{
    BisCount = 0;
    BisSuccess = 0;
    if(root)
    {
        SearchNode(root,k);
    }
}
void SearchNode(BiNode* &root,int k)
{
    BisCount++;
    if(root)
    {
        if(k==root->data)
        {
            BisSuccess = 1;//查找成功
            return;
        }
        else
        {
            if(k<root->data)
                SearchNode(root->lChild,k);
            else
                SearchNode(root->rChild,k);
		}
    }
    else//查找失败
    {
        BisSuccess = 0;
        BiNode *s = new BiNode;
        s->data = k;
        root = s;//查找不成功，插入新结点
	}
}
//非递归实现
int SearchBST(int k)
{
    BiNode *p = root,*q = p;
    //p为查找过程中进行扫描的指针，用一个q记录下当前的p
    while(p)
    {
        if(k==p->data)
            return 1;
        if(k<p->data)
        {
            q = p;
            p = p->lChild;//向左搜索
        }
        else
        {
            q = p;
            p = p->rChild;//向右搜索
        }
    }
    //查找不成功，生成一个新结点s，插入二叉排序树叶子处
    BiNode *s = new BiNode;
    s->data = k;
    if(!root)
        root = s;
    else if(k<q->data) q->lChild = s;//k比叶子小，挂左边
    else q->rChild = s;
    return 0;
}
```

二叉排序树是一种动态查找表。

当树中不存在查找的结点时，作插入操作

新插入的结点**一定是叶子结点**（只需改动一个结点的指针）

该叶子结点是查找不成功时路径上访问的最后一个结点的左孩子或右孩子（新结点值小于或大于该结点值）

**创建二叉排序树的过程使用中序遍历得到的序列就已经排好序。**

代码实现

```c++
#include<iostream>
using namespace std;
int flag, cnt;
class BiNode
{
public:
	int data;
	BiNode* lChild;
	BiNode* rChild;
	BiNode()
	{
		lChild = rChild = NULL;
	}
	BiNode(int e)
	{
		data = e;
		lChild = rChild = NULL;
	}
};
class BiTree
{
public:
	BiNode* root;
	BiTree()
	{
		root = NULL;
	}
	void insert(BiNode*& root, int data)
	{
		if (root == NULL)
		{
			root = new BiNode(data);
			return;
		}
		if (data < root->data)
			insert(root->lChild, data);
		else
			insert(root->rChild, data);
	}
	void search(BiNode* root, int k)
	{
		cnt++;
		if (root == NULL)
		{
			return;
		}
		if (k == root->data)
		{
			flag = 1;
			return;
		}
		if (k < root->data)
			search(root->lChild, k);
		else
			search(root->rChild, k);
	}
	void print(BiNode* root)
	{
		if (root == NULL)
			return;
		print(root->lChild);
		cout << root->data<<" ";
		print(root->rChild);
		return;
	}
};
int main()
{
	int t;
	cin >> t;
	BiTree B;
	while (t--)
	{
		int n;
		cin >> n;
		while (n--)
		{
			int data;
			cin >> data;
			B.insert(B.root, data);
		}
		B.print(B.root);
		cout << endl;
		int m;
		cin >> m;
		while (m--)
		{
			int k;
			cin >> k;
			cnt = flag = 0;
			B.search(B.root, k);
			if (flag)
				cout << cnt;
			else
				cout << "-1";
			cout << endl;
		}
	}
	return 0;
}
```



##### 二叉排序树的生成

```c++
void CreateTree()
{
    root = NULL;
    int n,data;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>data;
        SearchNode(root,data);//在二叉排序树中插入
	}
}
```

代码实现

```c++
//二叉排序树的创建和插入
#include<iostream>
using namespace std;
class BiNode
{
public:
	int data;
	BiNode* lChild;
	BiNode* rChild;
	BiNode()
	{
		lChild = NULL;
		rChild = NULL;
	}
	BiNode(int e)
	{
		data = e;
		lChild = rChild = NULL;
	}
};
class BiTree
{
public:
	BiNode* root;
	BiTree()
	{
		root = NULL;
	}
	void insert(BiNode*& root, int k)
	{
		if (root == NULL)
		{
			root = new BiNode(k);
			return;
		}
		if (root->data < k)
			insert(root->rChild, k);
		else
			insert(root->lChild, k);
	}
	void print(BiNode* root)
	{
		if (root == NULL)
			return;
		print(root->lChild);
		cout << root->data << " ";
		print(root->rChild);
		return;
	}
};
int main()
{
	int t;
	cin >> t;
	BiTree B;
	while (t--)
	{
		int n;
		cin >> n;
		while (n--)
		{
			int data;
			cin >> data;
			B.insert(B.root, data);
		}
		B.print(B.root);
		cout << endl;
		int m;
		cin >> m;
		while (m--)
		{
			int k;
			cin >> k;
			B.insert(B.root, k);
			B.print(B.root);
			cout << endl;
		}
	}
	return 0;
}
```



##### 删除

删除二叉排序树中的一个结点后，必须保持二叉排序树的特性。

三种情况：

1、被删除的结点为叶子节点

2、只有左子树或右子树

3、同时有左右子树

（1、2可以同时处理）

```c++
void deleteNode(BiNode* &ptr,int k)
{
    if(ptr)
    {
        if(k<ptr->data)
            deleteNode(ptr->lChild,k);
        else if(k>ptr->data)
            deleteNode(ptr->rChild,k);
        else
        {
            if(ptr->lChild&&ptr-rChild)
            {
                BiNode *temp = ptr->lChild;
                while(temp->rChild)
                {
                    temp = temp->rChild;
                }
                ptr->data = temp->data;
                deleteNode(ptr->lChild,temp->data);
            }
   		 	else
    		{
        		BiNode *temp = ptr;
                if(ptr->lChild == NULL)
                {
                    ptr = ptr->rChild;
                }
                else if(ptr->rChild==NULL)
                    ptr = ptr->lChild;
                delete temp;
    		}
        }
    }
}
```

代码实现

```c++
#include<iostream>
using namespace std;
class BiNode
{
public:
	int data;
	BiNode* lChild;
	BiNode* rChild;
	BiNode()
	{
		lChild = rChild = NULL;
	}
	BiNode(int e)
	{
		data = e;
		lChild = rChild = NULL;
	}
};
class BiTree
{
public:
	BiNode* root;
	BiTree()
	{
		root = NULL;
	}
	void insert(BiNode*& root, int data)
	{
		if (root == NULL)
		{
			root = new BiNode(data);
			return;
		}
		if (data < root->data)
			insert(root->lChild, data);
		else
			insert(root->rChild, data);
	}
	void Delete(BiNode*& ptr, int k)
	{
		if (ptr)
		{
			if (k < ptr->data)
				Delete(ptr->lChild, k);
			else if (k > ptr->data)
				Delete(ptr->rChild, k);
			else
			{
				if (ptr->lChild && ptr->rChild)
				{
					BiNode* temp = ptr->lChild;
					while (temp->rChild)
						temp = temp->rChild;
					ptr->data = temp->data;
					Delete(ptr->lChild, temp->data);
				}
				else
				{
					BiNode* temp = ptr;
					if (ptr->lChild == NULL)
						ptr = ptr->rChild;
					else if (ptr->rChild == NULL)
						ptr = ptr->lChild;
					delete temp;
				}
			}
		}
	}
	void print(BiNode* root)
	{
		if (root == NULL)
			return;
		print(root->lChild);
		cout << root->data << " ";
		print(root->rChild);
		return;
	}
};
int main()
{
	int t;
	cin >> t;
	BiTree B;
	while (t--)
	{
		int n;
		cin >> n;
		while (n--)
		{
			int data;
			cin >> data;
			B.insert(B.root, data);
		}
		B.print(B.root);
		cout << endl;
		int m;
		cin >> m;
		while (m--)
		{
			int k;
			cin >> k;
			B.Delete(B.root, k);
			B.print(B.root);
			cout << endl;
		}
	}
	return 0;
}
```



##### DS查找-二叉树平衡因子

```c++
#include<iostream>
using namespace std;
int height(char* arr, int n)
{
	if (arr[n] == '0')
		return 0;
	return height(arr, n * 2 + 1) > height(arr, n * 2 + 2) ? height(arr, n * 2 + 1) +1: height(arr, n * 2 + 2)+1;
}
void print(char* arr, int n)
{
	if (arr[n] == '0')
		return;
	print(arr, n * 2 + 1);
	print(arr, n * 2 + 2);
	cout << arr[n] << " " << height(arr, n * 2 + 1) - height(arr, n * 2 + 2) << endl;
}
int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		char* arr;
		int n;
		cin >> n;
		int a = 2;
		while (a / 2 < n)
			a *= 2;
		arr = new char[a + 3];
		for (int i = 0; i < n; i++)
			cin >> arr[i];
		for (int i = n; i < a; i ++ )
			arr[i] = '0';
		print(arr, 0);
	}
	return 0;
}
```



#### 平衡二叉树(AVL)

一、定义

平衡二叉树是二叉排序（查找）树的另一种形式

平衡二叉树又称AVL树

其特点为：树中每个结点的左右子树的深度之差的绝对值不大于1。

二、平衡因子

每个结点附加一个数字，给出该结点左子树的高度减去右子树的高度得到的高度差，这个数字即为结点的平衡因子balance

AVL树任一结点平衡因子只能取1，0，-1.

三、删除

如果被删结点没有孩子，则直接删除之，并做平衡化处理

如果被删结点A最多只有一个孩子，那么将结点A从树中删去，并将其双亲指向它的指针指向它的唯一孩子，并做平衡话处理

如果被删结点A有两个子女，则用结点的直接前驱S替代被删结点，然后对直接前驱S作删除处理，并做平衡话处理

#### B-树（一个填空题）

特殊的多路平衡查找树

m阶树（m个孩子）、m-1个关键字

Ki是关键字，从小到大排

Ai是指向子树根结点的指针

**对于m阶B-树，[m/2]-1<=n<=m-1(n为关键字个数)**(填空题！)

下限决定要不要进行合并操作，上限决定要不要进行分裂操作

在合理位置插，超出范围就分裂：m/2位置分裂出去，冲到上一阶

```c++
//需要的数据结构
int n;
int *key;
Node **t;//指针Ai指向结点

```

##### m阶B-树定义

树中每个结点至多有m棵子树（m-1个关键字）

插入结点一定是最底层结点

如果被插入的结点中关键字数目不大于m-2，则直接插入（插入后，关键字数目仍不大于m-1）

#### 哈希表

哈希表（散列表）是一种直接计算记录存放地址的方法，它在关键码与存储位置之间直接建立了映象。

哈希函数是从关键字空间到存储地址空间的一种映象

哈希函数在记录的关键字与记录的存储地址之间建立起一种对应关系。可写成：

addr(ai)=H(keyi)

keyi是表中元素ai关键字，addr（ai）是存储地址

**哈希查找**

首先利用哈希函数及记录的关键字计算出记录的存储地址

然后直接到指定地址进行查找

不需要经过比较，一次存取就能得到所查元素

**冲突**：不同的记录，其关键字通过哈希函数的计算，可能得到相同的地址，把不同的记录映射到同一个散列地址上，这种现象称为冲突。

#### 哈希函数

哈希函数实现的一般是从一个大的集合到一个小的集合的映射

##### 直接定址法

直接定址法中，哈希函数取关键字的线性函数

H(key)=a*key+b；其中ab为常数

特性：直接定址法仅适合于地址集合的大小与关键字集合的大小相等的情况

当a=1时，H(key)=key，即用关键字作为地址

在实际应用中能使用这种哈希函数的情况很少

##### 数字分析法

假设关键字集合中的每个关键字都是由s位数字组成（u1,u2,...,us)

分析关键字集中的全体

从中提取分布均匀的若干位或它们的组合作为地址

![image-20211206123720562](C:\Users\4334\AppData\Roaming\Typora\typora-user-images\image-20211206123720562.png)

![image-20211206123749885](C:\Users\4334\AppData\Roaming\Typora\typora-user-images\image-20211206123749885.png)

特性：数字分析法仅适用于事先明确知道表中所有关键码每一位数值的分布情况

数字分析法完全依赖于关键码集合

如果换一个关键码集合，选择哪几位要重新决定

##### 平方取中法

以关键字的平均值的中间几位作为存储地址

求“关键字的平方值”的目的是“扩大差别”

同时平方值的中间各位又能受到整个关键字中各位的影响

此方法在词典处理中使用十分广泛

它先计算构成关键码的标识符的内码的平方，然后按照散列表的大小取中间的若干位作为散列地址

特性：平方取中法是较常用的构造哈希函数的方法

适用于关键字中的每一位都有某些数字重复且频度很高的情况

中间所取位数，由哈希表长决定

##### 折叠法

将关键字分割成位数相同的若干部分（最后部分为位数可以不同），然后取它们的叠加和（舍去进位）为哈希地址

**移位叠加**：将分割后的几部分低位对齐相加

**间界叠加**：从一端沿分割界来回折叠，然后对齐相加

特性：适用于关键字的数字位数特别多，而且每一位上数字分布大致均匀的情况

##### 除留余数法

取关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址

H(key)=key MOD p(p<=m)

m为表长

p为不大于m的素数或是不含20以下的质因子

特性：除留余数法是一种最简单、最常用的构造哈希函数的方法

不但可以对关键字直接取模，也可在折叠、平方取中等运算之后取模

#### 处理冲突的方法

处理冲突的实际含义是：为产生冲突的地址寻找下一个哈希地址

处理冲突的方法：

##### 开放定址法

一、线性探测

当di取1,2,3,…,m-1时，称这种开放定址法为线性探测再散列

根据H(key)=key MOD p求出关键字集合的位置，填入位置

如果位置冲突，则新地址为：Hi=[H(key)+di] MOD m(di从1~m-1)

二、二次探测

当di取= 
$$
1^2,-1^2,2^2,-2^2,...,+-k^2(k<=m/2)
$$
时，称这种开放定址法为二次探测再散列

有地址冲突时始终是以第一个算出的地址出发重新计算地址。

特性：优点：只要哈希表中有空位置，总能找到一个不发生冲突的地址

缺点：易产生“二次聚集”，即在处理同义词的冲突过程中又添加了非同义词的冲突，对查找不利。

##### 链地址法

将所有哈希地址相同的记录都连接在同一链表中（表头插入）

```c++
class Node
{
public:
    int data;
    Node *next;
    Node()
    {
        data = 0;
        next = NULL;
    }
}
//哈希表类中需包含的相关变量
int HashListLen;//哈希表长
int p;//哈希因子
Node *HashTab;//表头数组
```

###### 查找

算法：

```c++
1、对于给定值key,计算哈希地址i=key%p;
2、指针r=HashTab[i].next;
3、r==NULL;//查找不成功
4、r->data = key;//查找成功
5、否则:r = r->next(求下一地址)，再转3
```

```c++
//若找到key，返回其结点指针；否则将其插入表中再返回其结点指针【链地址法解决冲突，表头插入】
void Search(int key)
{
    int i;
    Node *r,*q;
    i =key%p;
    r = HashTab[i].Next;
    HashCount = 0;
    while(r)
    {
        HashCount++;
        if(r->data==key)
        {
            HashSuccess = 1;
            return;
        }
        r = r->Next;
    }
    q = new Node;
    q->data = key;//查找不成功，在表头插入插入新结点
    q->Next = HashTab[i].Next;
    HashTab[i].Next = q;
    HashSuccess = 0;
}
//利用查找函数，生成Hash表
void CreateHashTab()
{
    cin>>HashListLen;
    HashTab = new Node[HashListLen];//头结点数组
    int n,key;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>key;
        Search(key);
    }
}
```

决定哈希表查找的ASL的因素：

1、选用的哈希函数

2、选用的处理冲突的方法

3、哈希表的装填因子

装填因子是哈希表中填入的记录数与哈希表的长度的比值，即：

α=哈希表中填入的记录数/哈希表的长度

直观来看：
装填因子α越小，发生冲突的可能性就越小
装填因子α越大，发生冲突的可能性就越大

### 内部排序

#### 排序

将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列

基本操作：比较&移动

#### 插入排序

基本思想：每步将一个待排序的对象，按其关键字大小，插入到前面已经排好序的有序表的适当位置上，直到对象全部插入为止

##### 直接插入排序

算法：

1、当插入第i(i≥1)个对象时, 前面的r[1], r[2], …, r[i-1]已经排好序。
2、用r[i]的关键字与r[i-1], r[i-2], …的关键字顺序进行比较(和顺序查找类似)，如果小于，则将r[x]向后移动(插入位置后的记录向后顺移)
3、找到插入位置即将r[i]插入

算法实现：

```c++
//生成顺序表
class List{
    int *key;
    int len;
    void InsertSort()
    {
        int i,j,temp;
        for(i=2;i<=len;i++)
        {
            temp = key[i];
            for(j=i-1;j>=1;j--)
            {
                if(temp<key[j])
                    key[j+1] = key[j];
                else
                    break;
            }
            key[j+1] = temp;
        }
    }
}
```

代码实现：

```c++
#include<iostream>
using namespace std;
class List
{
public:
	int* key;
	int len;
	List()
	{
		cin >> len;
		key = new int[len+2];
		for (int i = 1; i <= len; i++)
			cin >> key[i];
	}
	void Insert()
	{
		int i, j, temp;
		for (i = 2; i <= len; i++)
		{
			temp = key[i];
			for (j = i - 1; j >= 1; j--)
			{
				if (temp < key[j])
					key[j + 1] = key[j];
				else
					break;
			}
			key[j + 1] = temp;
		}
	}
};
int main()
{
	List L;
	L.Insert();
	return 0;
}
```



##### 折半插入排序

折半插入排序在查找记录插入位置时，采用折半查找算法
折半查找比顺序查找快, 所以折半插入排序在查找上性能比直接插入排序好(为O(nlog2n))
但需要移动的记录数目与直接插入排序相同(为O(n^2))
折半插入排序的时间复杂度为O(n^2)。
折半插入排序是一种稳定的排序方法

#### 插入排序--希尔排序

希尔排序方法是先将待排序序列分成若干子序列分别进行插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序

希尔排序又称缩小增量排序

**算法**

​	首先取一个整数gap<n（待排序记录数）作为间隔，将全部记录分为gap个子序列，所有距离为gap的记录放在同一个子序列中

​	在每一个子序列中分别施行直接插入排序

​	然后缩小间隔gap，例如取gap = gap/2

​	重复上述的子序列划分和排序工作，直到最后取gap=1，将所有记录放在同一个序列中

算法实现：

```c++
void ShellSort()
{
    int gap,m;
    for(gap = len/2;gap>=1;gap/=2)
    {
        for(m=1;m<=gap;m++)
            InsertSort(gap,m);
    }
}
void InsertSort(int gap,int m)//m为每个子序列的第一个元素
{
    int i,j,temp;
    for(i=gap+m;i<=len;i+=gap)//从第二个元素gap+m开始
    {
        temp = key[i];
        for(j=i-gap;j>0;j-=gap)
        {
            if(temp<key[j])
                key[j+gap] = key[j];
            else
                break;//找到新元素的位置
        }
        key[j+gap] = temp;
    }
}
```

算法分析：

只对特定的待排序记录序列，可以准确地估算关键字的比较次数和记录移动次数

希尔排序所需的比较次数和移动次数约为n^1.3^

当n趋于无穷时可减少到
$$
n*(log2n)^2
$$
希尔排序的时间复杂度约为
$$
O(n*(log2n)^2)
$$
希尔排序是一种不稳定的排序方法

代码实现：

```c++
#include<iostream>
using namespace std;
int main()
{
    int t;
    int *key;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        key = new int[n+1];
        for(int i=1;i<=n;i++)
            cin>>key[i];
        for(int gap = n/2;gap>=1;gap/=2)
        {
            for(int m = 1;m<=gap;m++)
            {
                for(int i = m+gap;i<=n;i+=gap)
                {
                    key[0] = key[i];
                    int j;
                    for(j = i-gap;j>0;j-=gap)
                    {
                        if(key[0]>key[j])
                            key[j+gap] = key[j];
                        else
                            break;
                    }
                    key[j+gap] = key[0];
                }
            }
            for(int i=1;i<n;i++)
                cout<<key[i]<<" ";
            cout<<key[n]<<endl;
        }
        cout<<endl;
    }
    return 0;
}
```

```c++
#include<iostream>
using namespace std;
int main()
{
	int t;
	cin >> t;
	int key[100];
	while (t--)
	{
		int n;
		cin >> n;
		for (int i = 1; i <= n; i++)
			cin >> key[i];
		for (int gap = n / 2; gap >= 1; gap /= 2)
		{
			for (int m = 1; m <= gap; m++)
			{
				for (int i = gap + m; i <= n; i += gap)
				{
					key[0] = key[i];
					int j;
					for (j = i - gap; j > 0; j -= gap)
					{
						if (key[0] < key[j])
							key[j + gap] = key[j];
						else
							break;
					}
					key[j + gap] = key[0];
				}
			}
			for (int i = 1; i <= n; i++)
				cout << key[i] << " ";
			cout << endl;
		}
	}
	return 0;
}
```



#### 快速排序

交换排序的基本思想是：两两比较待排序记录的关键码，如果发生逆序（即排列顺序与排序后的次序正好相反），则交换之，直到所有记录都排好序为止。

交换排序的主要算法：

起泡排序（冒牌排序）

快速排序

##### 起泡排序（冒泡排序）

一般地，第i趟起泡排序从1~n+1-i

依次比较相邻两个记录的关键字，如果发生逆序，则交换

其结果是这n+1-i个记录中，关键字最大的记录被交换到第n-i+1的位置上，最多做n-1趟

算法实现：

```c++
void BubbleSort()
{
    int i,j,temp;
    bool flag = true;
    for(i=1;i<len&&flag;i++)
    {
        flag = false;
        for(j=1;j<len-i+1;j++)
        {
            if(key[j]>key[j+1])
            {
                temp = key[j+1];
                key[j+1] = key[j];
                key[j] = temp;
                flag = true;
            }
        }
    }
}
```

最好的情况 时间复杂度：O(n)

最坏的情况：

 时间复杂度：O(n^2^)

执行n-1趟起泡,第i趟做n-i次关键字比较, 执行n-i次记录交换，共计：

![image-20211213141821407](C:\Users\4334\AppData\Roaming\Typora\typora-user-images\image-20211213141821407.png)

起泡排序是一种稳定的排序方法

代码实现：

```c++
#include<iostream>
using namespace std;
int main()
{
	int t;
	cin >> t;
	int key[100];
	while (t--)
	{
		int n;
		cin >> n;
		for (int i = 1; i <= n; i++)
			cin >> key[i];
		bool flag = true;
		for (int i = 1; i < n && flag; i++)
		{
			flag = false;
			for (int j = 1; j < n - i + 1; j++)
			{
				if (key[j] > key[j + 1])
				{
					key[0] = key[j + 1];
					key[j + 1] = key[j];
					key[j] = key[0];
					flag = true;
				}
			}
			for (int i = 1; i <= n; i++)
				cout << key[i] << " ";
			cout << endl;
		}
	}
	return 0;
}
```



##### 快速排序

任取待排序记录序列中的某个记录作为基准，按照记录的关键字大小，将整个记录序列划分为左右两个子序列：

左侧子序列所有记录的关键字都小于或等于基准

右侧子序列所有记录的关键字都大于或等于基准

基准记录排在这两个子序列中间

然后分别对这两个子序列重复施行上述方法，直到所有记录都排在相应位置上为止

基准记录也称为枢轴（或支点）记录

**算法**：

取序列第一个记录为枢轴记录，其关键字为pi

(如果保留最后一个元素为Pi，从low开始；保留第一个元素为Pi，从high开始)

指针low指向序列第一个记录位置

指针high指向序列最后一个记录位置

**一趟排序（某个子序列）过程：**

​	从high指向的记录开始，向前找到第一个关键字的值小于pi的记录，将其放到low指向的位置,low++

​	从low指向的记录开始，向后找到第一个关键字的值大于pi的记录，将其放到high指向的位置，high--

​	重复上述两个步骤，直到low=high，将枢轴记录放在low(high)指向的位置

算法实现：

```c++
void QuickSort(int low,int high)
{
    int i,j,Pi;
    i = low;
    j = high;
    Pi = key[low];
    while(low<high)
    {
        while(low<high && key[high]>=Pi)
            high--;
        if(low<high){
            key[low]=key[high];
            low++;
        }
        else
            break;
        while(low<high && key[low]<=Pi)
            low++;
        if(low<high)
        {
            key[high]=key[low];
            high--;
        }
    }
    key[low]=Pi;
    if(i<low-1) QuickSort(i,low-1);
    if(high+1<j) QuickSort(high+1,j);
}
//另一种写法
 int oneSort(int low, int high)
   {
       int Pivotkey;
       Pivotkey = data[low];
       while(low <high) {				//当high>low的时候循环
            while((low < high) && (Pivotkey <= data[high]))
                 high--;
            if(low < high)
                 data[low++] = data[high];
            else
                 break;
            while((low < high) && (data[low]<= Pivotkey))
                 low++;
            if(low < high) 
                data[high--] = data[low];
        }
      data[low] = Pivotkey;		 // low == high
      return low;
   }

    void QuickSort(int low, int high)
   {
       if(low<high){
         int temp=oneSort(low,high);
         QuickSort(low,temp-1);
         QuickSort(temp+1,high);
       }
   }
```

代码实现：

```c++
#include<iostream>
using namespace std;
int key[100];
int n;
int OneSort(int low, int high)
{
	int p = key[low];
	while (low < high)
	{
		while (low < high && key[high] >= p)
			high--;
		if (low < high)
		{
			key[low++] = key[high];
		}
		else
			break;
		while (low < high && key[low] <= p)
			low++;
		if (low < high)
		{
			key[high--] = key[low];
		}
	}
	key[low] = p;
	return low;
}
void QuickSort(int low, int high)
{
	if (low < high)
	{
		int temp = OneSort(low, high);
		for (int i = 1; i <= n; i++)
			cout << key[i] << " ";
		cout << endl;
		QuickSort(low, temp - 1);
		QuickSort(temp + 1, high);
	}
}
int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		cin >> n;
		for (int i = 1; i <= n; i++)
			cin >> key[i];
		QuickSort(1, n);
	}
	return 0;
}
```



#### 选择排序

选择排序有多种具体实现算法：

简单选择排序

堆排序

##### 简单选择排序

算法实现：

```c++
SelectSort(int n)
{
    int i,j,k,temp;
    for(i=1;i<n;i++)
    {
        k = i;
        for(j=i+1;j<=n;j++)
        {
            if(key[k]>key[j])
                k = j;
        }
        if(k!=i)
        {
            temp = key[k];
            key[k] = key[i];
            key[i] = temp;
        }
    }
}
```

代码实现：

```c++
#include<iostream>
using namespace std;
int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		int n;
		int* key;
		cin >> n;
		key = new int[n+1];
		for (int i = 1; i <= n; i++)
			cin >> key[i];
		for (int i = 1; i < n; i++)
		{
			int k = i;
			for (int j = i + 1; j <= n; j++)
			{
				if (key[k] > key[j])
					k = j;
			}
			if (k != i)
			{
				key[0] = key[k];
				key[k] = key[i];
				key[i] = key[0];
			}
			for (int i = 1; i <= n; i++)
				cout << key[i] << " ";
			cout << endl;
		}
	}
	return 0;
}
```



##### 堆排序

最大堆（大顶堆）：从大到小

最小堆（小顶堆）：从小到大

堆排序主要解决两个问题：

1 如何根据给定的序列建初始堆

2 如何在交换掉根结点后，将剩下的结点调整为新的堆（筛选）

**堆排序（筛选）**

·输出根结点

·用最后结点代替根结点值

·比较根结点与两个子结点的值，如果小于其中一个子结点，则选择大的子结点与根结点交换

·继续将交换的结点与其子结点比较

·直到叶子结点或者根结点值大于等于两个子结点

**堆排序（创建初始堆）**

·根据给定的序列，从1~n按顺序创建一个完全二叉树

·由最后一个非终端结点（第n/2个结点）开始至第一个结点，逐步做筛选（向叶子方向操作）

算法实现：

```c++
//最大堆
void shift(int k,int m)//结点k的调整过程，m为表长
{
    int i,j;
    i = k;
    j = 2*i;
    while(j<=m)
    {
        if(j<m&&data[j]<data[j+1])//比较i左右孩子谁大
            j++;
        if(data[i]>=data[j])//不需要交换，退出
            break;
        else
        {
            int temp = data[i];
            data[i] = data[j];
            data[j] = temp;
            i = j;
            j = 2*i;//继续下一趟
        }
    }
}
```

代码实现：

```c++
#include<iostream>
using namespace std;
void shift(int* data, int k, int n)
{
	int i, j;
	i = k;
	j = 2 * i;
	while (j <= n)
	{
		if (j<n && data[j]>data[j + 1])
			j++;
		if (data[i] <= data[j])
			break;
		else
		{
			data[0] = data[i];
			data[i] = data[j];
			data[j] = data[0];
			i = j;
			j = 2 * i;
		}
	}
}
int main()
{
	int n;
	cin >> n;
	int* data = new int[n + 1];
	for (int i = 1; i <= n; i++)
		cin >> data[i];
	for (int k = n / 2; k > 0; k--)
	{
		shift(data, k, n);
	}
	for (int i = n; i > 1; i--)
	{
		if (i == n)
		{
			cout << n << " ";
			for (int i = 1; i <= n; i++)
				cout << data[i] << " ";
			cout << endl;
		}
		int temp = data[i];
		data[i] = data[1];
		data[1] = temp;
		shift(data, 1, i-1);
		cout << n << " ";
		for (int i = 1; i <= n; i++)
			cout << data[i] << " ";
		cout << endl;
	}
	return 0;
}
```



#### 归并排序

归并是将两个或两个 以上的有序表合并成一个新的有序表的操作过程

##### 两路归并

算法实现：

```c++
void Merge(int left,int mid,int right)
{
    int i = left,j = mid+1,k = left;
    //i为第一个序列的第一个元素，j为第二个序列的第一个元素，k为合并后序列的第一个元素
    while(i<=mid&&j<=right)//两两比较将较小的并入
    {
        if(key[i]<=key[j])
            data[k++] = key[i++];
        else
            data[k++] = key[j++];
    }
    while(i<=mid)
        data[k++] = key[i++];//将mid前剩余的并入
    while(j<=right)
        data[k++] =key[j++];//将mid后剩余的并入
}
```

![image-20211220141406151](C:\Users\4334\AppData\Roaming\Typora\typora-user-images\image-20211220141406151.png)

##### 2路-归并排序

将n个记录看成n个有序序列，两两归并（需要log2n趟）

算法实现：

```c++
void MergeSort()
{
    int left,mid,right,step;
    for(step = 1;step<len;step*=2)//step表示每个子序列的长度
    {
        for(left = 1;left<=len;left+=2*step)
        {
            mid = left+step-1;//left指向第一个序列的第一个元素
            if(mid>=len)//mid指向第一个序列的最后元素
                break;
            right = left+2*step-1;//right指向第二个序列的最后元素
            if(right>len)
                right =len;
            Merge(left,mid,right);
        }
        for(int t = 1;t<=len;t++)//保留最后一趟排序结果
            key[t] = data[t];
    }
}
```

代码实现：

```c++
#include<iostream>
using namespace std;
int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		int n;
		cin >> n;
		int* data = new int[n + 1];
		int* key = new int[n + 1];
		for (int i = 1; i <= n; i++)
			cin >> key[i];
		int left, mid, right, step;
		for (step = 1; step < n; step *= 2)
		{
			for (left = 1; left <= n; left += 2 * step)
			{
				mid = left + step - 1;
				if (mid >= n)
				{
					data[mid] = key[mid];
					break;
				}
				right = left + 2 * step - 1;
				if (right > n)
					right = n;
				int i = left, j = mid + 1, k = left;
				while (i <= mid && j <= right)
				{
					if (key[i] <= key[j])
						data[k++] = key[i++];
					else
						data[k++] = key[j++];
				}
				while (i <= mid)
					data[k++] = key[i++];
				while (j <= right)
					data[k++] = key[j++];
			}
			for (int t = 1; t <= n; t++)
				key[t] = data[t];
			for (int i = 1; i <= n; i++)
				cout << key[i] << " ";
			cout << endl;
		}
	}
	return 0;
}
```



#### 基数排序

##### 多关键字的排序（最低为优先法LSD）

从最低位关键字kd起进行排序

然后再对高一位的关键字排序

依次重复，直至对最高位关键字k1排序后，便成为一个有序序列

##### 链式基数排序

数据结构：

```c++
class node
{
public:
	int e;
    node *next;
    node()
    {
        next = NULL;
    }
};
class Sort
{
    int len;//数据长度
    node *head;//头结点
    node *f[10];//队头指针
    node *r[10];//队尾指针
    int weishu;//处理位数
public://各种方法
};
```

```c++
//一趟分配和收集的过程
void RadixSort()
{
    int i;
    node *p;
    for(i=1;i<=weishu;i++)
    {
        init();//将队头队尾指针设置为NULL
        p = head->next;//开始一趟分配的过程
        while(p)
        {
            int w = (p->e/(int)pow(10,i-1))%10;//取得第i位的数据
            if(f[w] == NULL)
                f[w] = p;
            else
                r[w]->next = p;
            r[w] = p;
            p = p->next;
        }
        p = head;//开始一趟收集的过程
        for(int i=1;i<10;i++)//共10个队列
        {
            if(f[i])//若第i个队列不空
            {
                p->next = f[i];
                p = r[i];
            }
        }
        p->next = NULL;//收集结束，链表加上结束标志
    }
}
```

代码实现：

```c++
#include<iostream>
#include<cmath>
using namespace std;
class node
{
public:
	int data;
	node* next;
	node()
	{
		next = NULL;
	}
};
class Sort
{
	int len;
	int weishu;
	node* head;
	node* f[10];
	node* r[10];
public:
	Sort()
	{
		len = 0;
		weishu = 0;
		head = new node;
		for (int i = 0; i < 10; i++)
		{
			f[i] = new node;
			r[i] = new node;
		}
	}
	~Sort()
	{
		node* p = head;
		while (head)
		{
			p = head->next;
			delete head;
			head = p;
		}
	}
	void create()
	{
		cin >> len;
		node* p = head, * s;
		for (int i = 0; i < len; i++)
		{
			s = new node;
			cin >> s->data;
			int count = 1;
			int temp = s->data;
			while (temp / 10 != 0)
			{
				temp /= 10;
				count++;
				if (count > weishu)
					weishu = count;
			}
			s->next = p->next;
			p->next = s;
			p = s;
		}
	}
	void RadixSort()
	{
		int i;
		node* p;
		for (i = 1; i <= weishu; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				f[j] = NULL;
				r[j] = NULL;
			}
			p = head->next;
			while (p)
			{
				int w = (p->data / (int)pow(10, i - 1)) % 10;
				if (f[w] == NULL)
					f[w] = p;
				else
					r[w]->next = p;
				r[w] = p;
				p = p->next;
			}
			p = head;
			for (int i = 0; i < 10; i++)
			{
				if (f[i])
				{
					p->next = f[i];
					p = r[i];
				}
			}
			p->next = NULL;
			print();
		}
	}
	void print()
	{
		for (int i = 0; i < 10; i++)
		{
			cout << i << ":";
			if (f[i] == NULL)
				cout << "NULL" << endl;
			else
			{
				cout << "->";
				node* s = f[i];
				while (s != r[i]->next)
				{
					cout << s->data << "->";
					s = s->next;
				}
				cout << "^" << endl;
			}
		}
		node* p = head->next;
		while (p->next)
		{
			cout << p->data << " ";
			p = p->next;
		}
		cout << p->data << endl;
	}
};
int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		Sort S;
		S.create();
		S.RadixSort();
		cout << endl;
	}
	return 0;
}
```


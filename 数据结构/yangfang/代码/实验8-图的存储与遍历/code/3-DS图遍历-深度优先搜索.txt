//这道题因为顶点是数字0~n-1，因此就没有设立顶点数组，直接用数组下标表示
#include<iostream>
using namespace std;

class Map{
    int len; //顶点数
    int *v;  //访问标识数组
    int **p; //邻接矩阵
public:
    Map(){   //初始化：创建邻接矩阵
        int i,j;
        cin>>len;
        v=new int[len];
        for(i=0;i<len;i++)
            v[i]=0;

        p=new int*[len];
        for(i=0;i<len;i++){
            p[i]=new int[len];
            for(j=0;j<len;j++)
               cin>>p[i][j];
       }
    }

    void dsf(int k){ //DSF递归遍历
       cout<<k<<" ";   //访问顶点k
       v[k]=1;   //将标识位设置为1
       for(int i=0;i<len;i++){
          if(p[k][i] && !v[i]){   //找到和k相邻的下一个未访问的顶点，继续这个过程
             dsf(i);
          }
       }
    }

    void DFSTraverse(){  //如果图是非连通图，则需要多次调用DSF，完成所有顶点的遍历
      for(int i=0;i<len;i++)
        if(!v[i])
          dsf(i);
    }


    ~Map(){
        for(int i=0;i<len;i++)
            delete[] p[i];
        delete[] p;

        delete[] v;
        len=0;
    }
};

int main(){
    int t;
    cin>>t;
    while(t--){
        Map test;
        test.DFSTraverse();
        cout<<endl;
    }
    return 0;
}


/////////////////////////////////////
//另一种：非递归写法
#include<iostream>
#include<stack>
using namespace std;

class Map{
    int len; //顶点数
    int *v;  //访问标识数组
    int **p; //邻接矩阵
public:
    Map(){
        int i,j;
        cin>>len;
        v=new int[len];
        for(i=0;i<len;i++)
            v[i]=0;
        p=new int*[len];
        for(i=0;i<len;i++){
            p[i]=new int[len];
            for(j=0;j<len;j++)
               cin>>p[i][j];
       }
    }

    void dsf(int k){  //DSF非递归写法
       stack<int> s;
       int i,j;

       s.push(k);    //单独处理第一个结点
       cout<<k<<" ";
       v[k]=1;

       while(!s.empty()){
         i=s.top();
         for(j=0;j<len;j++){
            if(p[i][j] && !v[j]){
               cout<<j<<" ";
               v[j]=1;
               s.push(j);
               break;
            }
         }
         if(j==len) //若该顶点相邻的顶点都已经访问过了，则弹出
            s.pop();
       }
    }

    void DFSTraverse(){
      for(int i=0;i<len;i++)
        if(!v[i])
          dsf(i);
    }


    ~Map(){
        for(int i=0;i<len;i++)
            delete[] p[i];
        delete[] p;
        delete[] v;
        len=0;
    }
};

int main(){
    int t;
    cin>>t;
    while(t--){
        Map test;
        test.DFSTraverse();
        cout<<endl;
    }
    return 0;
}



